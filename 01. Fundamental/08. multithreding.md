```
threading is best to handle I/O-bound tasks
```

## 01. Using threading
```py
import threading

def thread_task(name):
    print(f"Task {name} is running")

task = 10
i = 0
max_worker = 5
thread_gather = []
while i < task
    for i in range(max_worker):
        if i < task:            
            thread = threading.Thread(target=thread_task, args=(i,))
            thread_gather.append(thread)
            thread_gather.start()
        else:
            print('All Task Appended')
            
for thread in thread_gather:
    thread.join()
```
## 02. Using concurrent.futures

```py
import concurrent.futures
import time

def io_task(name, duration):
    print(f"Starting task {name}")
    time.sleep(duration)  # Simulating an I/O-bound task
    print(f"Finished task {name}")
    return name, duration

max_worker = 5
task = 10
with concurrent.futures.ThreadPoolExecutor(max_workers=max_worker) as executor:
    i = 0
    thread_gather = []
    while i < task:
       for i in range(max_worker):
            if i < task:
                thread_gather.append(executor.submit(io_task, 'task name',5))   # first arg func name, next arguments of func
            else:
                print('All Task Appended')

       # Retrieve and print results
       for future in concurrent.futures.as_completed(futures):
            try:
                result = future.result()
                print(f"Result: {result}")
            except Exception as ops:
                print(f"Error: {ops}")
```
